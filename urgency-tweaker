#!/usr/bin/env python3

import curses
import subprocess
import sys
from pathlib import Path

# ----------------------------
# paths
# ----------------------------

TASK_DIR = Path.home() / ".task"
CONFIG_DIR = TASK_DIR / "config"
USER_RC = CONFIG_DIR / "urgency.rc"

# ----------------------------
# UI context block (edit freely)
# ----------------------------

UI_HELP_TEXT = [
    "This interface edits Taskwarrior urgency coefficients.",
    "Loaded from ~/.task/config/urgency.rc (if present).",
    "Values marked with * differ from Taskwarrior defaults.",
]

# ----------------------------
# rc file header (edit freely)
# ----------------------------

RC_HEADER = """\
# urgency.rc — generated by urgency-tweaker
#
# This file contains Taskwarrior urgency coefficients.
# Lines annotated with a default value indicate deviation
# from Taskwarrior's built-in defaults.
#
# To reset to defaults, remove this file or un-include it
# from your .taskrc.
#
"""

# ----------------------------
# Taskwarrior urgency defaults
# ----------------------------

DEFAULT_URGENCY = {
    "urgency.age": 2.0,
    "urgency.annotations": 1.0,
    "urgency.blocked": -5.0,
    "urgency.blocking": 5.0,
    "urgency.due": 12.0,
    "urgency.project": 1.0,
    "urgency.scheduled": 5.0,
    "urgency.tags": 1.0,
    "urgency.priority.H": 6.0,
    "urgency.priority.M": 3.0,
    "urgency.priority.L": 1.0,
    "urgency.waiting": -3.0,
}

# ----------------------------
# rc parsing / writing
# ----------------------------

def parse_rc(path: Path) -> dict:
    data = {}
    if not path.exists():
        return data

    for line in path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue

        key, rest = line.split("=", 1)

        # strip inline comments
        value = rest.split("#", 1)[0].strip()

        try:
            data[key.strip()] = float(value)
        except ValueError:
            continue

    return data

def write_user_rc(data: dict):
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)

    lines = []

    for k in sorted(data.keys()):
        v = data[k]

        if k in DEFAULT_URGENCY:
            default = DEFAULT_URGENCY[k]
            if v != default:
                line = f"{k}={v}    # default={default}"
            else:
                line = f"{k}={v}"
        else:
            # no known default (e.g. UDA)
            line = f"{k}={v}"

        lines.append(line)

    content = RC_HEADER + "\n".join(lines) + "\n"
    USER_RC.write_text(content)

# ----------------------------
# UDA discovery
# ----------------------------

def discover_udas():
    udas = []
    try:
        out = subprocess.check_output(
            ["task", "show"], text=True, stderr=subprocess.DEVNULL
        )
        for line in out.splitlines():
            if line.startswith("uda.") and line.endswith(".type"):
                name = line.split(".")[1]
                udas.append(f"urgency.uda.{name}")
    except Exception:
        pass
    return udas

# ----------------------------
# data preparation
# ----------------------------

def load_coeffs(categories):
    # start from immutable defaults
    coeffs = dict(DEFAULT_URGENCY)

    # overlay user config
    coeffs.update(parse_rc(USER_RC))

    # add UDAs dynamically (default = 0)
    for uda in discover_udas():
        coeffs.setdefault(uda, 0.0)

    # optional category filtering
    if categories:
        coeffs = {
            k: v for k, v in coeffs.items()
            if any(k.startswith(f"urgency.{c}") for c in categories)
        }

    return coeffs


def is_modified(key, value):
    return value != DEFAULT_URGENCY.get(key, 0.0)

# ----------------------------
# curses UI
# ----------------------------

def ui(stdscr, coeffs):
    curses.curs_set(0)
    stdscr.keypad(True)

    keys = sorted(coeffs.keys(), key=lambda k: coeffs[k], reverse=True)
    selected = 0

    while True:
        stdscr.clear()
        h, w = stdscr.getmaxyx()
        y = 0

        # title
        stdscr.addstr(y, 0, "urgency-tweaker", curses.A_BOLD)
        y += 2

        # context block
        for line in UI_HELP_TEXT:
            if y < h:
                stdscr.addstr(y, 0, line[:w])
                y += 1

        # separator
        if y < h:
            stdscr.addstr(y, 0, "─" * (w - 1))
            y += 1

        list_start = y

        # list rendering
        for i, k in enumerate(keys):
            row = list_start + i
            if row >= h:
                break

            val = coeffs[k]
            marker = "*" if is_modified(k, val) else " "
            line = f"{k:<30} {val:>6.1f} {marker}"

            if i == selected:
                stdscr.addstr(row, 0, line[:w], curses.A_REVERSE)
            else:
                stdscr.addstr(row, 0, line[:w])

        stdscr.refresh()
        ch = stdscr.getch()

        if ch in (ord("q"), ord("Q")):
            break
        elif ch == curses.KEY_UP and selected > 0:
            selected -= 1
        elif ch == curses.KEY_DOWN and selected < len(keys) - 1:
            selected += 1
        elif ch == curses.KEY_LEFT:
            key = keys[selected]
            coeffs[key] -= 1
            keys.sort(key=lambda k: coeffs[k], reverse=True)
            selected = keys.index(key)
        elif ch == curses.KEY_RIGHT:
            key = keys[selected]
            coeffs[key] += 1
            keys.sort(key=lambda k: coeffs[k], reverse=True)
            selected = keys.index(key)
    return coeffs

# ----------------------------
# main
# ----------------------------

def main():
    categories = sys.argv[1:]

    coeffs = load_coeffs(categories)
    if not coeffs:
        print("No matching urgency coefficients.")
        sys.exit(1)

    final = curses.wrapper(ui, coeffs)
    write_user_rc(final)


if __name__ == "__main__":
    main()

